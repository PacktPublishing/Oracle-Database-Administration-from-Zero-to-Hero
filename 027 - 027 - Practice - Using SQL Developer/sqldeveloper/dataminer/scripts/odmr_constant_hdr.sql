
  CREATE OR REPLACE PACKAGE "ODMRSYS"."ODMR_CONSTANT" 
AUTHID CURRENT_USER AS

  /* Global settings */
  -- algorithm settings as defined in DBMS_DM
  /* Depreciated
  ABNS_MAX_BUILD_MINUTES        CONSTANT VARCHAR2(30) := 'ABNS_MAX_BUILD_MINUTES';
  ABNS_MAX_NB_PREDICTORS        CONSTANT VARCHAR2(30) := 'ABNS_MAX_NB_PREDICTORS';
  ABNS_MAX_PREDICTORS           CONSTANT VARCHAR2(30) := 'ABNS_MAX_PREDICTORS';
  ABNS_MODEL_TYPE               CONSTANT VARCHAR2(30) := 'ABNS_MODEL_TYPE';
  */

  /* Association Rules settings */
  -- Maximum rule length for Association Rules. 2<= numeric_expr <=20
  ASSO_MAX_RULE_LENGTH          CONSTANT VARCHAR2(30) := 'ASSO_MAX_RULE_LENGTH';
  -- Minimum confidence for Association Rules, 0<= numeric_expr <=1
  ASSO_MIN_CONFIDENCE           CONSTANT VARCHAR2(30) := 'ASSO_MIN_CONFIDENCE';
  -- Minimum support for Association Rules, 0<= numeric_expr <=1
  ASSO_MIN_SUPPORT              CONSTANT VARCHAR2(30) := 'ASSO_MIN_SUPPORT';
  -- Minimum reverse confidence for Association Rules. Rule >= 1
  ASSO_MIN_REV_CONFIDENCE       CONSTANT VARCHAR2(30) := 'ASSO_MIN_REV_CONFIDENCE';
  -- Minimum support count Association Rules. Rule >= 1
  ASSO_MIN_SUPPORT_INT          CONSTANT VARCHAR2(30) := 'ASSO_MIN_SUPPORT_INT';
  -- Antecedent including rules
  ASSO_ANT_IN_RULES             CONSTANT VARCHAR2(30) := 'ASSO_ANT_IN_RULES';
  -- Consequent including rules
  ASSO_CONS_IN_RULES            CONSTANT VARCHAR2(30) := 'ASSO_CONS_IN_RULES';
  -- Antecedent excluding rules
  ASSO_ANT_EX_RULES             CONSTANT VARCHAR2(30) := 'ASSO_ANT_EX_RULES';
  -- Consequent excluding rules
  ASSO_CONS_EX_RULES            CONSTANT VARCHAR2(30) := 'ASSO_CONS_EX_RULES';
  -- Item Aggregates
  ASSO_AGGREGATES               CONSTANT VARCHAR2(30) := 'ASSO_AGGREGATES';
  -- Sample setting
  ODMS_SAMPLING                 CONSTANT VARCHAR2(30) := 'ODMS_SAMPLING';
  -- Sample enabled
  ODMS_SAMPLING_ENABLE          CONSTANT VARCHAR2(30) := 'ODMS_SAMPLING_ENABLE';
  -- Sample disabled
  ODMS_SAMPLING_DISABLE         CONSTANT VARCHAR2(30) := 'ODMS_SAMPLING_DISABLE';
  -- Sample size
  ODMS_SAMPLE_SIZE              CONSTANT VARCHAR2(30) := 'ODMS_SAMPLE_SIZE';
  -- Item ID
  ODMS_ITEM_ID_COLUMN_NAME      CONSTANT VARCHAR2(30) := 'ODMS_ITEM_ID_COLUMN_NAME';
  -- Item Value (optional)
  ODMS_ITEM_VALUE_COLUMN_NAME   CONSTANT VARCHAR2(30) := 'ODMS_ITEM_VALUE_COLUMN_NAME';
  -- This setting is used to control the parallel build of partitioned models
  ODMS_PARTITION_BUILD_TYPE     CONSTANT VARCHAR2(30) := 'ODMS_PARTITION_BUILD_TYPE';

  /* Clustering settings */
  -- Number of clusters generated by a clustering algorithm, numeric_expr >=1
  CLUS_NUM_CLUSTERS             CONSTANT VARCHAR2(30) := 'CLUS_NUM_CLUSTERS';

  /* KMean settings */
  -- Growth factor for memory allocated to hold cluster data.
  -- Default is 2. 1< numeric_expr <=5
  KMNS_BLOCK_GROWTH             CONSTANT VARCHAR2(30) := 'KMNS_BLOCK_GROWTH';
  -- Convergence tolerance for k-Means algorithm
  -- Default is 0.01. 0< numeric_expr <=0.5
  KMNS_CONV_TOLERANCE           CONSTANT VARCHAR2(30) := 'KMNS_CONV_TOLERANCE';
  -- Distance Function for k-Means Clustering. The default is euclidean.
  KMNS_DISTANCE                 CONSTANT VARCHAR2(30) := 'KMNS_DISTANCE';
  KMNS_COSINE                   CONSTANT VARCHAR2(30) := 'KMNS_COSINE';
  KMNS_EUCLIDEAN                CONSTANT VARCHAR2(30) := 'KMNS_EUCLIDEAN';
  KMNS_FAST_COSINE              CONSTANT VARCHAR2(30) := 'KMNS_FAST_COSINE';
  -- Number of iterations for k-Means algorithm
  -- Default is 3. 0< numeric_expr <=20
  KMNS_ITERATIONS               CONSTANT VARCHAR2(30) := 'KMNS_ITERATIONS';
  -- The fraction of attribute values that must be non-null in order for the attribute to be included in the rule description for the cluster.
  -- Setting the parameter value too high in data with missing values can result in very short or even empty rules.
  -- Default is 0.1. 0<= numeric_expr <=1
  KMNS_MIN_PCT_ATTR_SUPPORT     CONSTANT VARCHAR2(30) := 'KMNS_MIN_PCT_ATTR_SUPPORT';
  -- Number of histogram bins. Specifies the number of bins in the attribute histogram produced by k-Means. The bin boundaries for each attribute are computed globally on the entire training data set. The binning method is equi-width. All attributes have the same number of bins with the exception of attributes with a single value that have only one bin.
  -- Default is 10. numeric_expr >0
  KMNS_NUM_BINS                 CONSTANT VARCHAR2(30) := 'KMNS_NUM_BINS';
  -- Split criterion for k-Means Clustering. The default criterion is the variance.
  KMNS_SPLIT_CRITERION          CONSTANT VARCHAR2(30) := 'KMNS_SPLIT_CRITERION';
  KMNS_SIZE                     CONSTANT VARCHAR2(30) := 'KMNS_SIZE';
  KMNS_VARIANCE                 CONSTANT VARCHAR2(30) := 'KMNS_VARIANCE';

  -- Level of Details for k-Means Clustering. The default value is all.
  KMNS_DETAILS                  CONSTANT VARCHAR2(30) := 'KMNS_DETAILS';
  KMNS_LEVEL_DETAILS_NONE       CONSTANT VARCHAR2(30) := 'NONE';
  KMNS_LEVEL_DETAILS_HIERARCHY  CONSTANT VARCHAR2(30) := 'HIERARCHY';
  KMNS_LEVEL_DETAILS_ALL        CONSTANT VARCHAR2(30) := 'ALL';
  
  -- Random seed for k-Means Clustering. Value >=0, default 0
  KMNS_RANDOM_SEED              CONSTANT VARCHAR2(30) := 'KMNS_RANDOM_SEED';

  /* OCluster settings */
  -- Buffer size for O-Cluster.
  -- Default is 50,000. numeric_expr >0
  OCLT_MAX_BUFFER               CONSTANT VARCHAR2(30) := 'OCLT_MAX_BUFFER';
  -- A fraction that specifies the peak density required for separating a new cluster. The fraction is related to the global uniform density.
  -- Default is 0.5. 0 <=numeric_expr <=1
  OCLT_SENSITIVITY              CONSTANT VARCHAR2(30) := 'OCLT_SENSITIVITY';

  /* Expectation Maximization */
  -- If we use only default settings, the number of clusters defaults to 10 and the number of components defaults to 20. By default, component clustering is enabled.
  -- If the user disables component clustering, both the number of clusters and the number of components default to 20.
  -- If the user specifies number of components but not number of clusters, the number of clusters will be the smaller of 10 and number of components.
  -- If the user specifies number of clusters but not number of components, the number of components is the greater of 20 and the number of clusters.
  -- If the user disables components clustering and specifies either number of components or number of clusters, the other setting defaults to the same value.
  -- Number of clusters generated by a algorithm, numeric_expr >=1
  --CLUS_NUM_CLUSTERS             CONSTANT VARCHAR2(30) := 'CLUS_NUM_CLUSTERS';
  ODMS_APPROXIMATE_COMPUTATION  CONSTANT VARCHAR2(30) := 'ODMS_APPROXIMATE_COMPUTATION';
  ODMS_APPR_COMP_ENABLE         CONSTANT VARCHAR2(30) := 'ODMS_APPR_COMP_ENABLE';
  ODMS_APPR_COMP_DISABLE        CONSTANT VARCHAR2(30) := 'ODMS_APPR_COMP_DISABLE';
  -- TO_CHAR( numeric_expr >=1)
  -- Maximum number of components in the model. The algorithm automatically determines the number of components, based on improvements in the likelihood function or based on regularization, up to the specified maximum.
  -- The number of components needs to greater than or equal to the number of clusters.
  -- Default is 20.
  EMCS_NUM_COMPONENTS	          CONSTANT VARCHAR2(30) := 'EMCS_NUM_COMPONENTS';
  -- Enables or disables the grouping of EM components into high-level clusters. When disabled, the components themselves are treated as clusters.
  -- When component clustering is enabled, model scoring through the SQL CLUSTER function will produce assignments to the higher level clusters. When clustering is disabled, the CLUSTER function will produce assignments to the original components.
  -- Default is EMCS_CLUSTER_COMP_ENABLE.
  EMCS_CLUSTER_COMPONENTS       CONSTANT VARCHAR2(30) := 'EMCS_CLUSTER_COMPONENTS';
  EMCS_CLUSTER_COMP_ENABLE      CONSTANT VARCHAR2(30) := 'EMCS_CLUSTER_COMP_ENABLE';
  EMCS_CLUSTER_COMP_DISABLE     CONSTANT VARCHAR2(30) := 'EMCS_CLUSTER_COMP_DISABLE';
  -- TO_CHAR( numeric_expr >=1)
  -- Allows the specification of a dissimilarity threshold value that controls the clustering of EM components. Smaller values may produce more clusters that will be more compact while large values may produce fewer clusters that will be more spread out.
  -- Default is 2.0.
  EMCS_CLUSTER_THRESH           CONSTANT VARCHAR2(30) := 'EMCS_CLUSTER_THRESH';
  -- TO_CHAR( numeric_expr >=1)
  -- Specifies the maximum number of correlated two-dimensional attributes that will be used in the EM model. Two-dimensional attributes correspond to columns that are not nested; they are not stored within nested columns.
  -- Default is 100.
  EMCS_MAX_NUM_ATTR_2D          CONSTANT VARCHAR2(30) := 'EMCS_MAX_NUM_ATTR_2D';
  -- TO_CHAR( numeric_expr >=1)
  -- Specifies the number of projections that will be used for each nested column. If a column has fewer distinct attributes than the specified number of projections, the data will not be projected. The setting applies to all nested columns.
  -- Default is 50.
  EMCS_NUM_PROJECTIONS          CONSTANT VARCHAR2(30) := 'EMCS_NUM_PROJECTIONS';
  -- TO_CHAR( numeric_expr >=1)
  -- Specifies the number of quantile bins that will be used for modeling numerical columns with multivalued Bernoulli distributions.
  -- Default is system-determined.
  EMCS_NUM_QUANTILE_BINS        CONSTANT VARCHAR2(30) := 'EMCS_NUM_QUANTILE_BINS';
  -- TO_CHAR( numeric_expr >=1)
  -- Specifies the number of top-N bins that will be used for modeling categorical columns with multivalued Bernoulli distributions.
  -- Default is system-determined.
  EMCS_NUM_TOPN_BINS            CONSTANT VARCHAR2(30) := 'EMCS_NUM_TOPN_BINS';
  -- TO_CHAR( numeric_expr >=1)
  -- Number of equi-width bins that will be used for gathering cluster statistics for numerical columns.
  -- Default is 11.
  EMCS_NUM_EQUIWIDTH_BINS       CONSTANT VARCHAR2(30) := 'EMCS_NUM_EQUIWIDTH_BINS';
  -- TO_CHAR( 0 < numeric_expr < 1)
  -- Specifies what percentage of the data rows assigned to a cluster need to be present in an attribute to include that attribute in the cluster rule.
  -- Default is 0.1
  EMCS_MIN_PCT_ATTR_SUPPORT     CONSTANT VARCHAR2(30) := 'EMCS_MIN_PCT_ATTR_SUPPORT';
  -- Enables or disables the gathering of cluster descriptive statistics (centroids, histograms, and rules) Disabling the cluster statistics will result in smaller models and will reduce the output of GET_MODEL_DETAILS_EM.
  -- Default is EMCS_CLUS_STATS_ENABLE.
  EMCS_CLUSTER_STATISTICS       CONSTANT VARCHAR2(30) := 'EMCS_CLUSTER_STATISTICS';
  EMCS_CLUS_STATS_ENABLE        CONSTANT VARCHAR2(30) := 'EMCS_CLUS_STATS_ENABLE';
  EMCS_CLUS_STATS_DISABLE       CONSTANT VARCHAR2(30) := 'EMCS_CLUS_STATS_DISABLE';
  -- Enables the binning of numerical attributes using Bernoulli distributions, Gaussian distributions, or a system-determined distribution on a per-attribute basis.
  -- Default is EMCS_NUM_DISTR_SYSTEM
  EMCS_NUM_DISTRIBUTION         CONSTANT VARCHAR2(30) := 'EMCS_NUM_DISTRIBUTION';
  EMCS_NUM_DISTR_BERNOULLI      CONSTANT VARCHAR2(30) := 'EMCS_NUM_DISTR_BERNOULLI';
  EMCS_NUM_DISTR_GAUSSIAN       CONSTANT VARCHAR2(30) := 'EMCS_NUM_DISTR_GAUSSIAN';
  EMCS_NUM_DISTR_SYSTEM         CONSTANT VARCHAR2(30) := 'EMCS_NUM_DISTR_SYSTEM';
  -- TO_CHAR( numeric_expr >=1)
  -- Specifies the maximum number of iterations in the EM core algorithm. Applies to the input table/view as a whole and does not allow per attribute specification.
  -- Default is 100.
  EMCS_NUM_ITERATIONS           CONSTANT VARCHAR2(30) := 'EMCS_NUM_ITERATIONS';
  -- TO_CHAR( 0 < numeric_expr < 1)
  -- Specifies the percentage improvement in the value of the log likelihood function required to add a new component to the model.
  -- Default value is 0.001.
  EMCS_LOGLIKE_IMPROVEMENT      CONSTANT VARCHAR2(30) := 'EMCS_LOGLIKE_IMPROVEMENT';
  -- Allows the specification of a linkage function for the agglomerative clustering step.
  -- EMCS_LINKAGE_SINGLE uses the nearest distance within the branch. The clusters tend to be larger and have arbitrary shapes.
  -- EMCS_LINKAGE_AVERAGE uses the average distance within the branch. There is less chaining effect and the clusters are more compact.
  -- EMCS_LINKAGE_COMPLETE uses the maximum distance within the branch. The clusters are smaller and require strong component overlap.
  -- Default is EMCS_LINKAGE_SINGLE.
  EMCS_LINKAGE_FUNCTION         CONSTANT VARCHAR2(30) := 'EMCS_LINKAGE_FUNCTION';
  EMCS_LINKAGE_SINGLE           CONSTANT VARCHAR2(30) := 'EMCS_LINKAGE_SINGLE';
  EMCS_LINKAGE_AVERAGE          CONSTANT VARCHAR2(30) := 'EMCS_LINKAGE_AVERAGE';
  EMCS_LINKAGE_COMPLETE         CONSTANT VARCHAR2(30) := 'EMCS_LINKAGE_COMPLETE';
  EMCS_CONVERGENCE_CRITERION    CONSTANT VARCHAR2(30) := 'EMCS_CONVERGENCE_CRITERION';
  EMCS_CONV_CRIT_HELDASIDE      CONSTANT VARCHAR2(30) := 'EMCS_CONV_CRIT_HELDASIDE';
  EMCS_CONV_CRIT_BIC            CONSTANT VARCHAR2(30) := 'EMCS_CONV_CRIT_BIC';
  -- Specifies whether uncorrelated two-dimensional attributes should be included in the model or not. Two-dimensional attributes correspond to columns that are not nested; they are not stored within nested columns.
  -- Default is system-determined.
  EMCS_ATTRIBUTE_FILTER         CONSTANT VARCHAR2(30) := 'EMCS_ATTRIBUTE_FILTER';
  EMCS_ATTR_FILTER_ENABLE       CONSTANT VARCHAR2(30) := 'EMCS_ATTR_FILTER_ENABLE';
  EMCS_ATTR_FILTER_DISABLE      CONSTANT VARCHAR2(30) := 'EMCS_ATTR_FILTER_DISABLE';
  
  -- new in 12.2
  -- This setting controls the seed of the random generator used in EM. It should be a non-negative integer value. 
  -- The default is 0.
  EMCS_RANDOM_SEED            CONSTANT VARCHAR2(30) := 'EMCS_RANDOM_SEED';
  
  -- This setting enables model search in EM where different model sizes are explored and a best size is selected.
  -- The values for this setting are: EMCS_MODEL_SEARCH_ENABLE and EMCS_MODEL_SEARCH_DISABLE (default).
  EMCS_MODEL_SEARCH           CONSTANT VARCHAR2(30) := 'EMCS_MODEL_SEARCH';
  
  -- This setting allows the EM algorithm to remove very small components from the solution. 
  -- The values are EMCS_REMOVE_COMPS_ENABLE (default) and EMCS_REMOVE_COMPS_DISABLE.
  EMCS_REMOVE_COMPONENTS      CONSTANT VARCHAR2(30) := 'EMCS_REMOVE_COMPONENTS';
    
  /* GLM settings */
  -- The confidence level for coefficient confidence intervals.
  -- The default confidence level is 0.95. 0< numeric_expr <1
  GLMS_CONF_LEVEL             CONSTANT VARCHAR2(30) := 'GLMS_CONF_LEVEL';
  -- The name of a table to contain row-level diagnostic information for a GLM model. The table is created during model build.
  -- If you want to create a diagnostics table, you must specify a case ID when you build the model. (See the CREATE_MODEL Procedure.) If you specify a diagnostics table but do not provide a case ID, an exception is raised.
  GLMS_DIAGNOSTICS_TABLE_NAME CONSTANT VARCHAR2(30) := 'GLMS_DIAGNOSTICS_TABLE_NAME';
  
    --This setting allows the user to request row diagnostics
  GLMS_ROW_DIAGNOSTICS          CONSTANT VARCHAR2(30) := 'GLMS_ROW_DIAGNOSTICS';
  
  -- The target value to be used as a reference in a binary logistic regression model. Probabilities will be produced for the other (non-reference) class.
  -- By default, the algorithm choses the value with the highest prevalence (the most cases) for the reference class.
  GLMS_REFERENCE_CLASS_NAME   CONSTANT VARCHAR2(30) := 'GLMS_REFERENCE_CLASS_NAME';
  -- Whether or not ridge regression will be enabled. By default, the algorithm determines whether or not to use ridge. You can explicitly enable ridge by setting GLMS_RIDGE_REGRESSION to GLMS_RIDGE_REG_ENABLE.
  -- Ridge applies to both regression and classification mining functions.
  -- When ridge is enabled, VIF is not produced  unless you set GLMS_VIF_FOR_RIDGE to GLMS_VIF_RIDGE_ENABLE and adequate system resources are available. GLMS_VIF_FOR_RIDGE applies to linear regression only. GLMS_VIF_FOR_RIDGE can only be specified when you explicitly enable ridge.
  -- When ridge is enabled, no prediction bounds are produced by the PREDICTION_BOUNDS SQL operator.
  GLMS_RIDGE_REGRESSION       CONSTANT VARCHAR2(30) := 'GLMS_RIDGE_REGRESSION';
  GLMS_RIDGE_REG_ENABLE       CONSTANT VARCHAR2(30) := 'GLMS_RIDGE_REG_ENABLE';
  GLMS_RIDGE_REG_DISABLE      CONSTANT VARCHAR2(30) := 'GLMS_RIDGE_REG_DISABLE';
  -- The value for the ridge parameter used by the algorithm. This setting is only used when you explicitly enable ridge regression by setting GLMS_RIDGE_REGRESSION to GLMS_RIDGE_REG_ENABLE.
  -- If ridge regression is enabled internally by the algorithm, the ridge parameter is determined by the algorithm.
  -- 0< numeric_expr
  GLMS_RIDGE_VALUE            CONSTANT VARCHAR2(30) := 'GLMS_RIDGE_VALUE';
  -- Whether or not to produce Variance Inflation Factor (VIF) statistics when ridge is being used for linear regression. When you explicitly enable ridge regression by setting GLMS_RIDGE_REGRESSION to GLMS_RIDGE_REG_ENABLE, you can request VIF statistics by setting GLMS_VIF_FOR_RIDGE to GLMS_VIF_RIDGE_ENABLE; the algorithm will produce VIF if enough system resources are available.
  GLMS_VIF_FOR_RIDGE          CONSTANT VARCHAR2(30) := 'GLMS_VIF_FOR_RIDGE';
  GLMS_VIF_RIDGE_ENABLE       CONSTANT VARCHAR2(30) := 'GLMS_VIF_RIDGE_ENABLE';
  GLMS_VIF_RIDGE_DISABLE      CONSTANT VARCHAR2(30) := 'GLMS_VIF_RIDGE_DISABLE';
  -- Feature selection penalty criterion for adding a feature into the model.
  -- By default, the algorithm chooses the penalty criterion based on the data.
  GLMS_FTR_SEL_CRIT           CONSTANT VARCHAR2(30) := 'GLMS_FTR_SEL_CRIT';
  GLMS_FTR_SEL_AIC            CONSTANT VARCHAR2(30) := 'GLMS_FTR_SEL_AIC';
  GLMS_FTR_SEL_SBIC           CONSTANT VARCHAR2(30) := 'GLMS_FTR_SEL_SBIC';
  GLMS_FTR_SEL_RIC            CONSTANT VARCHAR2(30) := 'GLMS_FTR_SEL_RIC';
  GLMS_SEL_ALPHA_INV          CONSTANT VARCHAR2(30) := 'GLMS_FTR_SEL_ALPHA_INV';
  -- Maximum number of features allowed in the model
  -- By default, the algorithm chooses the maximum based on the data.
  -- 0 < numeric_expr
  GLMS_MAX_FEATURES           CONSTANT VARCHAR2(30) := 'GLMS_MAX_FEATURES';
  -- When enabled, the entire group of binary exploded categorical values is added to the model at once. When disabled, they are added one at a time.
  -- Default is GLMS_SELECT_BLOCK_DISABLE.
  GLMS_SELECT_BLOCK           CONSTANT VARCHAR2(30) := 'GLMS_SELECT_BLOCK';
  GLMS_SELECT_BLOCK_DISABLE   CONSTANT VARCHAR2(30) := 'GLMS_SELECT_BLOCK_DISABLE';
  GLMS_SELECT_BLOCK_ENABLE    CONSTANT VARCHAR2(30) := 'GLMS_SELECT_BLOCK_ENABLE';

  --ODMS_APPROXIMATE_COMPUTATION   CONSTANT VARCHAR2(30) := 'ODMS_APPROXIMATE_COMPUTATION';
  --  ODMS_APPR_COMP_ENABLE       CONSTANT VARCHAR2(30) := 'ODMS_APPR_COMP_ENABLE';
  --  ODMS_APPR_COMP_DISABLE      CONSTANT VARCHAR2(30) := 'ODMS_APPR_COMP_DISABLE';

  -- When enabled, the algorithm prunes the final model using t-statistics. When disabled, the algorithm does not prune the final model.    
  -- Default is GLMS_PRUNE_MODEL_ENABLE.
  GLMS_PRUNE_MODEL              CONSTANT VARCHAR2(30) := 'GLMS_PRUNE_MODEL';
  GLMS_PRUNE_MODEL_ENABLE       CONSTANT VARCHAR2(30) := 'GLMS_PRUNE_MODEL_ENABLE';
  GLMS_PRUNE_MODEL_DISABLE      CONSTANT VARCHAR2(30) := 'GLMS_PRUNE_MODEL_DISABLE';
  -- Focus protection effort against admitting.
  -- By default, the algorithm chooses whether to use strict or relaxed acceptance based on the data.    
  GLMS_FTR_ACCEPTANCE           CONSTANT VARCHAR2(30) := 'GLMS_FTR_ACCEPTANCE';
  GLMS_FTR_ACCEPTANCE_STRICT    CONSTANT VARCHAR2(30) := 'GLMS_FTR_ACCEPTANCE_STRICT';
  GLMS_FTR_ACCEPTANCE_RELAXED   CONSTANT VARCHAR2(30) := 'GLMS_FTR_ACCEPTANCE_RELAXED';

  GLMS_FTR_SELECTION            CONSTANT VARCHAR2(30) := 'GLMS_FTR_SELECTION';
  GLMS_FTR_SELECTION_ENABLE     CONSTANT VARCHAR2(30) := 'GLMS_FTR_SELECTION_ENABLE';
  GLMS_FTR_SELECTION_DISABLE    CONSTANT VARCHAR2(30) := 'GLMS_FTR_SELECTION_DISABLE';

  GLMS_FTR_GENERATION           CONSTANT VARCHAR2(30) := 'GLMS_FTR_GENERATION';
  GLMS_FTR_GENERATION_ENABLE    CONSTANT VARCHAR2(30) := 'GLMS_FTR_GENERATION_ENABLE';
  GLMS_FTR_GENERATION_DISABLE   CONSTANT VARCHAR2(30) := 'GLMS_FTR_GENERATION_DISABLE';

  GLMS_FTR_GEN_METHOD           CONSTANT VARCHAR2(30) := 'GLMS_FTR_GEN_METHOD';
  GLMS_FTR_GEN_QUADRATIC        CONSTANT VARCHAR2(30) := 'GLMS_FTR_GEN_QUADRATIC';
  GLMS_FTR_GEN_CUBIC            CONSTANT VARCHAR2(30) := 'GLMS_FTR_GEN_CUBIC';
    
  -- determines the convergence tolerance of the GLM algorithm. 
  -- The value should be in the range (0, 1) non-inclusive. The default is system determined.
  GLMS_CONV_TOLERANCE           CONSTANT VARCHAR2(30) := 'GLMS_CONV_TOLERANCE';
  --This setting controls the maximum number of iterations for the GLM algorithm. 
  -- The value needs to be a positive integer. The default is system determined
  GLMS_NUM_ITERATIONS           CONSTANT VARCHAR2(30) := 'GLMS_NUM_ITERATIONS';
  -- This setting controls the number of rows in a batch used by the GLMS solver. 
  -- It sets the size of the batch for the SGD solver. The value needs to be a positive integer. The default is 2000.
  GLMS_BATCH_ROWS               CONSTANT VARCHAR2(30) := 'GLMS_BATCH_ROWS';
  
  -- This setting allows the user to choose the GLM solver and SPARSE Solver
  GLMS_SOLVER                   CONSTANT VARCHAR2(30) := 'GLMS_SOLVER';
  GLMS_SPARSE_SOLVER            CONSTANT VARCHAR2(30) := 'GLMS_SPARSE_SOLVER';
  

  /* NB settings */
  -- Value of pairwise threshold for NB algorithm
  -- Default is 0.01. 0<= numeric_expr <=1
  NABS_PAIRWISE_THRESHOLD       CONSTANT VARCHAR2(30) := 'NABS_PAIRWISE_THRESHOLD';
  -- Value of singleton threshold for NB algorithm
  -- Default value is 0.01. 0<= numeric_expr <=1
  NABS_SINGLETON_THRESHOLD      CONSTANT VARCHAR2(30) := 'NABS_SINGLETON_THRESHOLD';

  /* NMF settings */
  -- Number of features to be extracted by a feature extraction model.
  -- The default is estimated from the data by the algorithm.  1 <= numeric_expr
  FEAT_NUM_FEATURES             CONSTANT VARCHAR2(30) := 'FEAT_NUM_FEATURES';
  -- Convergence toerance for NMF algorithm
  -- Default is 0.05. 0< numeric_expr <=0.5
  NMFS_CONV_TOLERANCE           CONSTANT VARCHAR2(30) := 'NMFS_CONV_TOLERANCE';
  -- Number of iterations for NMF algorithm
  -- Default is 50. 1 <= numeric_expr <=500
  NMFS_NUM_ITERATIONS           CONSTANT VARCHAR2(30) := 'NMFS_NUM_ITERATIONS';
  -- Random seed for NMF algorithm.
  -- Default is -1.
  NMFS_RANDOM_SEED              CONSTANT VARCHAR2(30) := 'NMFS_RANDOM_SEED';
  
  -- Non negatvie Scoring for NMF algorithm.
  -- Default is NMFS_NONNEG_SCORING_ENABLE
  NMFS_NONNEGATIVE_SCORING      CONSTANT VARCHAR2(30) := 'NMFS_NONNEGATIVE_SCORING';
  

  /* SVD and PCA settings */
  -- Number of features to be extracted by a feature extraction model.
  -- The default is estimated from the data by the algorithm.  1 <= numeric_expr
  --FEAT_NUM_FEATURES             CONSTANT VARCHAR2(30) := 'FEAT_NUM_FEATURES';
  -- Whether or not to persist the U matrix produced by SVD.
  -- The U matrix in SVD has as many rows as the number of rows in the build data. To avoid creating a large model, the U matrix is persisted only when SVDS_U_MATRIX_OUTPUT is enabled.
  -- When SVDS_U_MATRIX_OUTPUT is enabled, the build data must include a case ID. If no case ID is present and the U matrix is requested, an exception is raised.
  -- Default is SVDS_U_MATRIX_DISABLE.
  SVDS_U_MATRIX_OUTPUT          CONSTANT VARCHAR2(30) := 'SVDS_U_MATRIX_OUTPUT';
  SVDS_U_MATRIX_ENABLE          CONSTANT VARCHAR2(30) := 'SVDS_U_MATRIX_ENABLE';
  SVDS_U_MATRIX_DISABLE         CONSTANT VARCHAR2(30) := 'SVDS_U_MATRIX_DISABLE';
  -- Whether or not SVD should approximate low-rank decomposition.
  -- A full SVD decomposition is usually impractical for a dataset with many columns. An approximate low-rank decomposition provides good solutions at a reasonable computation cost. SVD approximates unless SVDS_APPROXIMATE_COMPUTATION is disabled.
  -- When SVDS_APPROXIMATE_COMPUTATION is disabled, approximatation is dependent on the characteristics of the build data. For datasets with very large number of attributes (over 2500) only approximate decomposition is possible. If approximate computation is disabled for a dataset with more attributes than the maximum number of features allowed (2500), an exception is raised.
  -- Default is SVDS_APPR_COMP_ENABLE.
  --ODMS_APPROXIMATE_COMPUTATION  CONSTANT VARCHAR2(30) := 'ODMS_APPROXIMATE_COMPUTATION';
  --  ODMS_APPR_COMP_ENABLE         CONSTANT VARCHAR2(30) := 'ODMS_APPR_COMP_ENABLE';
  --  ODMS_APPR_COMP_DISABLE        CONSTANT VARCHAR2(30) := 'ODMS_APPR_COMP_DISABLE';
  -- Whether to use SVD or PCA scoring for the model. The SQL FEATURE scoring functions produce either SVD or PCA projections depending on the value of SVDS_SCORING_MODE.
  -- When the build data is scored with SVD, the projections will be the same as the U matrix. When the build data is scored with PCA, the projections will be the same as the U and S matrices.
  -- When PCA is chosen, the SQL FEATURE functions will produce PCA projections. If the build data is scored, the projections will correspond to the matrix product of the U and S matrices.
  -- Default is SVDS_SCORING_SVD.
  SVDS_SCORING_MODE             CONSTANT VARCHAR2(30) := 'SVDS_SCORING_MODE';
  SVDS_SCORING_SVD              CONSTANT VARCHAR2(30) := 'SVDS_SCORING_SVD';
  SVDS_SCORING_PCA              CONSTANT VARCHAR2(30) := 'SVDS_SCORING_PCA';
    
  -- The following settings are new in 12.2: 
  -- SVDS_SOLVER, SVDS_TOLERANCE, SVDS_OVER_SAMPLING, SVDS_POWER_ITERATIONS, SVDS_RANDOM_SEED
  -- This setting indicates the solver to be used for computing the Singular Value Decomposition (SVD) of the data. 
  -- In the case of PCA, the solver setting indicates the type of SVD solver used to compute the PCA for the data. 
  -- Solvers are divided into two groups: narrow data solvers (tall-skinny SVD solvers) and wide data solvers
  -- (stochastic SVD solvers).
  SVDS_SOLVER                  CONSTANT VARCHAR2(30) := 'SVDS_SOLVER';
  
  -- This setting is used to prune features. Define the minimum value the eigenvalue of a feature needs to have as a 
  -- share of the first eigenvalue in order not to be pruned. The default is zero (to be changed to:
  -- max(ncols, nrows)*DBL_EPSILON). The range is (0, 1).
  SVDS_TOLERANCE               CONSTANT VARCHAR2(30) := 'SVDS_TOLERANCE';
 
  -- The random seed value is used for initializing the sampling matrix used by the Stochastic SVD solver.
  -- The default is 0. The value falls in the range [0 - 4,294,967,296].
  SVDS_RANDOM_SEED             CONSTANT VARCHAR2(30) := 'SVDS_RANDOM_SEED';
  
  -- This setting is used to configure the number of columns in the sampling matrix used by the Stochastic SVD solver. 
  -- The number of columns in this matrix is equal to the requested number of features plus the oversampling setting.
  SVDS_OVER_SAMPLING           CONSTANT VARCHAR2(30) := 'SVDS_OVER_SAMPLING';
  
  -- The power iteration setting is used to improve the accuracy of the SSVD solver. In general a power iterations 
  -- setting of 2 is sufficient for most problems. The higher the setting the longer it takes to train the 
  -- model. The default is 2. The value needs to be in the range [0, 20]. 
  SVDS_POWER_ITERATIONS         CONSTANT VARCHAR2(30) := 'SVDS_POWER_ITERATIONS';
  
  /* SVM settings */
  -- Whether active learning is enabled or disabled. By default, active learning is enabled.
  -- When active learning is enabled, the SVM algorithm uses active learning to build a reduced size model. When active learning is disabled, the SVM algorithm builds a standard model.
  SVMS_ACTIVE_LEARNING          CONSTANT VARCHAR2(30) := 'SVMS_ACTIVE_LEARNING';
  SVMS_AL_DISABLE               CONSTANT VARCHAR2(30) := 'SVMS_AL_DISABLE';
  SVMS_AL_ENABLE                CONSTANT VARCHAR2(30) := 'SVMS_AL_ENABLE';
  -- Value of complexity factor for SVM algorithm (both classification and regression)
  -- efault value estimated from the data by the algorithm. numeric_expr >0
  SVMS_COMPLEXITY_FACTOR        CONSTANT VARCHAR2(30) := 'SVMS_COMPLEXITY_FACTOR';
  --Convergence tolerance for SVM algorithm
  -- Default is 0.001. numeric_expr >0
  SVMS_CONV_TOLERANCE           CONSTANT VARCHAR2(30) := 'SVMS_CONV_TOLERANCE';
  -- Value of epsilon factor for SVM regression
  -- Default value estimated from the data by the algorithm. numeric_expr >0
  SVMS_EPSILON                  CONSTANT VARCHAR2(30) := 'SVMS_EPSILON';
  -- Value of kernel cache size for SVM algorithm. Applies to Gaussian kernel only.
  -- Default is 50000000 bytes. numeric_expr >0
  SVMS_KERNEL_CACHE_SIZE        CONSTANT VARCHAR2(30) := 'SVMS_KERNEL_CACHE_SIZE';
  -- Kernel for Support Vector Machine. The default kernel is linear.
  SVMS_KERNEL_FUNCTION          CONSTANT VARCHAR2(30) := 'SVMS_KERNEL_FUNCTION';
  SVMS_GAUSSIAN                 CONSTANT VARCHAR2(30) := 'SVMS_GAUSSIAN';
  SVMS_LINEAR                   CONSTANT VARCHAR2(30) := 'SVMS_LINEAR';
  -- The desired rate of outliers in the training data. Valid for One-Class SVM models only (anomaly detection).
  -- Default is 0.1. 0< numeric_expr <1
  SVMS_OUTLIER_RATE             CONSTANT VARCHAR2(30) := 'SVMS_OUTLIER_RATE';
  -- Value of standard deviation for SVM algorithm
  -- This is applicable only for Gaussian kernel
  -- Default value estimated from the data by the algorithm. numeric_expr >0
  SVMS_STD_DEV                  CONSTANT VARCHAR2(30) := 'SVMS_STD_DEV';
  
  -- This setting controls the type of regularization used by the SGD SVM solver. 
  -- The setting can be used only for linear SVM models. The values are SVMS_REGULARIZER_L1 and SVMS_REGULARIZER_L2.
  -- The default is system determined because it depends on the potential model size. 12_2 and up.
  SVMS_REGULARIZER              CONSTANT VARCHAR2(30) := 'SVMS_REGULARIZER';
  
  -- This setting applies on to SVM models with linear kernel. It sets the size of the batch for the SGD solver. 
  -- The value needs to be a positive integer. An input of 0 triggers a data driven batch size estimate. 12_2 and up.
  -- The default is 20000.
  SVMS_BATCH_ROWS               CONSTANT VARCHAR2(30) := 'SVMS_BATCH_ROWS';
  
  -- This setting allows the user to choose the SVM solver. The values are SVMS_SOLVER_SGD (Sub-Gradient Descend) and
  -- SVMS_SOLVER_IPM (Interior Point Method). The SGD solver cannot be selected if the kernel is non-linear.12_2 and up.
  -- The default value is system determined.
  SVMS_SOLVER                   CONSTANT VARCHAR2(30) := 'SVMS_SOLVER';
  
  -- This setting sets an upper limit on the number of SVM iterations. The value needs to be a positive integer. 
  -- The default is system determined because it depends on the SVM solver.12_2 and up.
  SVMS_NUM_ITERATIONS           CONSTANT VARCHAR2(30) := 'SVMS_NUM_ITERATIONS';
  
  -- This setting sets an upper limit on the number of pivots used in the Incomplete Cholesky decomposition. 
  -- It can be set only for non-linear kernels. The value needs to be a positive integer in the range [1; 10000].
  -- The default is 200.12_2 and up.
  SVMS_NUM_PIVOTS               CONSTANT VARCHAR2(30) := 'SVMS_NUM_PIVOTS';

  /* ESA settings */
  -- Top N Feature
  -- Default value is 1000
  ESAS_TOPN_FEATURES            CONSTANT VARCHAR2(30) := 'ESAS_TOPN_FEATURES';
  -- Minimum Items
  -- Default value is 100
  ESAS_MIN_ITEMS                CONSTANT VARCHAR2(30) := 'ESAS_MIN_ITEMS';
  -- Threshold Value
  -- Default value is 0.00000001
  ESAS_VALUE_THRESHOLD          CONSTANT VARCHAR2(30) := 'ESAS_VALUE_THRESHOLD';  
  
  /* Decision Tree Settings */
  -- Tree impurity metric for Decision Tree.
  -- Tree algorithms seek the best test question for splitting data at each node. The best splitter and split value are those that result in the largest increase in target value homogeneity (purity) for the entities in the node. Purity is measured in accordance with a metric. Decision trees can use either gini (TREE_IMPURITY_GINI) or entropy (TREE_IMPURITY_ENTROPY) as the purity metric. By default, the algorithm uses gini.
  TREE_IMPURITY_METRIC          CONSTANT VARCHAR2(30) := 'TREE_IMPURITY_METRIC';
  -- Criteria for splits: maximum tree depth (the maximum number of nodes between the root and any leaf node, including the leaf node).
  -- Default is 7. 2<= numeric_expr <=20
  TREE_TERM_MAX_DEPTH           CONSTANT VARCHAR2(30) := 'TREE_TERM_MAX_DEPTH';
  -- No child shall have fewer records than this number, which is expressed as a percentage of the training rows.
  -- Default is 0.05, indicating 0.05%. 0<= numeric_expr <=10
  TREE_TERM_MINPCT_NODE         CONSTANT VARCHAR2(30) := 'TREE_TERM_MINPCT_NODE';
  -- Criteria for splits: minimum number of records in a parent node expressed as a percent of the total number of records used to train the model. No split is attempted if number of records is below this value.
  -- Default is 0.1, indicating 0.1%. 0 <= numeric_expr <=20
  TREE_TERM_MINPCT_SPLIT        CONSTANT VARCHAR2(30) := 'TREE_TERM_MINPCT_SPLIT';
  -- No child shall have fewer records than this number.
  -- Default is 10. numeric_expr >=0
  TREE_TERM_MINREC_NODE         CONSTANT VARCHAR2(30) := 'TREE_TERM_MINREC_NODE';
  -- Criteria for splits: minimum number of records in a parent node expressed as a value. No split is attempted if number of records is below this value.
  -- Default is 20. numeric_expr >=0
  TREE_TERM_MINREC_SPLIT        CONSTANT VARCHAR2(30) := 'TREE_TERM_MINREC_SPLIT';
  -- Maximum Supervised Bins
  CLAS_MAX_SUP_BINS             CONSTANT VARCHAR2(30) := 'CLAS_MAX_SUP_BINS';
  /* Global settings (only applicable for GLM now) */
  -- (GLM only) How to treat missing values in the training data. This setting does not affect the scoring data.
  ODMS_MISSING_VALUE_TREATMENT  CONSTANT VARCHAR2(30) := 'ODMS_MISSING_VALUE_TREATMENT';
  -- Missing values treatment Options
  -- Oracle Data Mining replaces missing values with the mean (numeric attributes) or the mode (categorical attributes) both at build time and apply time.
  ODMS_MISSING_VALUE_MEAN_MODE  CONSTANT VARCHAR2(30) := 'ODMS_MISSING_VALUE_MEAN_MODE';
  -- You can set ODMS_MISSING_VALUE_TREATMENT to ODMS_MISSING_VALUE_DELETE_ROW to override this behavior in the training data.
  -- When ODMS_MISSING_VALUE_TREATMENT is set to ODMS_MISSING_VALUE_DELETE_ROW, the rows in the training data that contain missing values are deleted. However, if you want to replicate this missing value treatment in the scoring data, you must perform the transformation manually.
  -- The value ODMS_MISSING_VALUE_DELETE_ROW is only valid for tables without nested columns. If this value is used with nested data, an exception is raised.
  ODMS_MISSING_VALUE_DELETE_ROW CONSTANT VARCHAR2(30) := 'ODMS_MISSING_VALUE_DELETE_ROW';
  -- (GLM only) Name of a column in the training data that contains a weighting factor for the rows.
  -- Row weights can be used as a compact representation of repeated rows, as in the design of experiments where a specific configuration is repeated several times. Row weights can also be used to emphasize certain rows during model construction. For example, to bias the model towards rows that are more recent and away from potentially obsolete data.
  ODMS_ROW_WEIGHT_COLUMN_NAME   CONSTANT VARCHAR2(30) := 'ODMS_ROW_WEIGHT_COLUMN_NAME';
  PREP_AUTO                     CONSTANT VARCHAR2(30) := 'PREP_AUTO';

  /* R build settings 
   * R scripts must be previously registered
   */
  RALG_BUILD_FUNCTION   CONSTANT VARCHAR2(30) := 'RALG_BUILD_FUNCTION';
  -- Build parameter must be extracted from the metadata as a SQL select statement
  RALG_BUILD_PARAMETER  CONSTANT VARCHAR2(30) := 'RALG_BUILD_PARAMETER';
  RALG_SCORE_FUNCTION   CONSTANT VARCHAR2(30) := 'RALG_SCORE_FUNCTION';
  RALG_WEIGHT_FUNCTION  CONSTANT VARCHAR2(30) := 'RALG_WEIGHT_FUNCTION';
  RALG_DETAILS_FUNCTION CONSTANT VARCHAR2(30) := 'RALG_DETAILS_FUNCTION';
  -- Details format also need to be extracted as a SQL select statement
  RALG_DETAILS_FORMAT   CONSTANT VARCHAR2(30) := 'RALG_DETAILS_FORMAT';
  -- Algorithm constants | For R models the algorithm must not be provided, instead the ALGO_EXTENSIBLE_LANG settings
  -- However, I'm including the algorithm for uniformity purposes in the code, and to avoid conditionals in the INTERNAL_BUILD_PROG procedure
  RALG_EXTENSIBLE       CONSTANT VARCHAR2(30) := 'RALG_EXTENSIBLE';
  RALG_EXTENSIBLE_LANG  CONSTANT VARCHAR2(30) := 'R';
  ALGO_EXTENSIBLE_LANG  CONSTANT VARCHAR2(30) := 'ALGO_EXTENSIBLE_LANG';
  -- activity level settings
  WORKFLOW_SETTING_TEST_MAPPING CONSTANT VARCHAR2(30) := 'WORKFLOW_SETTING_TEST_MAPPING'; -- Use activity level test data mapping:1 If not, use the test split data
  WORKFLOW_SETTING_SPLIT_PERC   CONSTANT VARCHAR2(30) := 'WORKFLOW_SETTING_SPLIT_PERC';   -- Build split percent, test percent = (1 - build split percent)

  -- build settings for classification models (performance balance option)
  BUILD_SETTING_PERFORM_OPTION  CONSTANT VARCHAR2(30) := 'BUILD_SETTING_PERFORM_OPTION';
  BUILD_SETTING_PERFORM_OP_AVG  CONSTANT VARCHAR2(30) := 'BUILD_SETTING_PERFORM_OP_AVG';
  BUILD_SETTING_PERFORM_OP_OVRL CONSTANT VARCHAR2(30) := 'BUILD_SETTING_PERFORM_OP_OVRL';
  BUILD_SETTING_PERFORM_OP_CUST CONSTANT VARCHAR2(30) := 'BUILD_SETTING_PERFORM_OP_CUST';
  -- internal use (cost benefit cost matrix source indicator)
  BUILD_SETTING_CSTBENFIT_OPTION  CONSTANT VARCHAR2(30) := 'BUILD_SETTING_CSTBENFIT_OPTION';
  BUILD_SETTING_CSTBNF_OP_NONE    CONSTANT VARCHAR2(30) := 'BUILD_SETTING_CSTBNF_OP_NONE';    -- no cost to use
  BUILD_SETTING_CSTBNF_OP_TRUE    CONSTANT VARCHAR2(30) := 'BUILD_SETTING_CSTBNF_OP_TRUE';    -- use true cost (user specified)
  BUILD_SETTING_CSTBNF_OP_TUNED   CONSTANT VARCHAR2(30) := 'BUILD_SETTING_CSTBNF_OP_TUNED';   -- use tuned cost (from ROC)
  BUILD_SETTING_NB_USE_PRIOR      CONSTANT VARCHAR2(30) := 'BUILD_SETTING_NB_USE_PRIOR';      -- Use Prior or not for NB build

  -- test settings
  TEST_SETTING_LIFT_QUANTILES   CONSTANT VARCHAR2(30) := 'TEST_SETTING_LIFT_QUANTILES';
  TEST_SETTING_USE_MAPPING      CONSTANT VARCHAR2(30) := 'TEST_SETTING_USE_MAPPING';  -- Use custom data mapping:2 If not, use the activity level test data mapping
  TEST_SETTING_USE_ARCHIVE      CONSTANT VARCHAR2(30) := 'TEST_SETTING_USE_ARCHIVE';  -- Archive test results:3
  -- test result tables (classification)
  PERFORM_METRICS_TABLE_NAME    CONSTANT VARCHAR2(30) := 'PERFORM_METRICS_TABLE_NAME';
  LIFT_RESULT_TABLE_NAME        CONSTANT VARCHAR2(30) := 'LIFT_RESULT_TABLE_NAME';
  ROC_RESULT_TABLE_NAME         CONSTANT VARCHAR2(30) := 'ROC_RESULT_TABLE_NAME';
  CONFUSION_MATRIX_TABLE_NAME   CONSTANT VARCHAR2(30) := 'CONFUSION_MATRIX_TABLE_NAME';
  ROC_RESULT_AREA_UNDER_CURVE   CONSTANT VARCHAR2(30) := 'ROC_RESULT_AREA_UNDER_CURVE';

  -- test result tables (regression)
  RESIDUAL_PLOT_TABLE_NAME      CONSTANT VARCHAR2(30) := 'RESIDUAL_PLOT_TABLE_NAME';

  -- apply settings
  APPLY_SETTING_USE_MAPPING       CONSTANT VARCHAR2(30) := 'APPLY_SETTING_USE_MAPPING';   -- Use custom data mapping:4 If not, use the activity level apply data mapping
  APPLY_SETTING_USE_ARCHIVE       CONSTANT VARCHAR2(30) := 'APPLY_SETTING_USE_ARCHIVE';   -- Archive apply results:5
  APPLY_SETTING_OPTION            CONSTANT VARCHAR2(30) := 'APPLY_SETTING_OPTION';        -- Apply option - top N, specific target values, etc
  APPLY_SETTING_OPTION_TOPN       CONSTANT VARCHAR2(30) := 'APPLY_SETTING_OPTION_TOPN';   -- Top N
  APPLY_SETTING_OPTION_TARGETS    CONSTANT VARCHAR2(30) := 'APPLY_SETTING_OPTION_TARGETS';-- Specific target values
  APPLY_SETTING_PROB_COL          CONSTANT VARCHAR2(30) := 'APPLY_SETTING_PROB_COL';      -- Probability column name
  APPLY_SETTING_PRED_COL          CONSTANT VARCHAR2(30) := 'APPLY_SETTING_PRED_COL';      -- Prediction column name
  APPLY_SETTING_RANK_COL          CONSTANT VARCHAR2(30) := 'APPLY_SETTING_RANK_COL';      -- Rank column name
  APPLY_SETTING_COST_COL          CONSTANT VARCHAR2(30) := 'APPLY_SETTING_COST_COL';      -- Cost column name
  APPLY_SETTING_NODE_COL          CONSTANT VARCHAR2(30) := 'APPLY_SETTING_NODE_COL';      -- Node column name
  APPLY_SETTING_CLUSTER_ID_COL    CONSTANT VARCHAR2(30) := 'APPLY_SETTING_CLUSTER_ID_COL';-- Cluster id column name
  APPLY_SETTING_FEATURE_ID_COL    CONSTANT VARCHAR2(30) := 'APPLY_SETTING_FEATURE_ID_COL';-- Feature id column name
  APPLY_SETTING_FEATURE_VAL_COL   CONSTANT VARCHAR2(30) := 'APPLY_SETTING_FEATURE_VAL_COL';-- Feature value column name
  APPLY_SETTING_PROB_LOWER_COL    CONSTANT VARCHAR2(30) := 'APPLY_SETTING_PROB_LOWER_COL';-- Probability Lower Bound column name
  APPLY_SETTING_PROB_UPPER_COL    CONSTANT VARCHAR2(30) := 'APPLY_SETTING_PROB_UPPER_COL';-- Probability Upper Bound column name
  APPLY_SETTING_PRED_LOWER_COL    CONSTANT VARCHAR2(30) := 'APPLY_SETTING_PRED_LOWER_COL';-- Prediction Lower Bound column name
  APPLY_SETTING_PRED_UPPER_COL    CONSTANT VARCHAR2(30) := 'APPLY_SETTING_PRED_UPPER_COL';-- Prediction Upper Bound column name

  APPLY_SETTING_USE_SUPPL       CONSTANT VARCHAR2(30) := 'APPLY_SETTING_USE_SUPPL';     -- Use nodel level specific supplemental attributes:6 If not, use the activity level specific supplemental attributes
  -- apply result table
  APPLY_RESULT_TABLE_NAME       CONSTANT VARCHAR2(30) := 'APPLY_RESULT_TABLE_NAME';

  -- activity state
  WORKFLOW_STATUS_INACTIVE      CONSTANT VARCHAR2(30) := 'INACTIVE';    -- Workflow is idle
  WORKFLOW_STATUS_RUNNING       CONSTANT VARCHAR2(30) := 'RUNNING';     -- Workflow is being executed
  WORKFLOW_STATUS_STOPPING      CONSTANT VARCHAR2(30) := 'STOPPING';    -- Workflow is being stopped
  WORKFLOW_STATUS_STOPPED       CONSTANT VARCHAR2(30) := 'STOPPED';     -- Workflow is stopped
  WORKFLOW_STATUS_SUCCEEDED     CONSTANT VARCHAR2(30) := 'SUCCEEDED';   -- Workflow run succeeds
  WORKFLOW_STATUS_FAILED        CONSTANT VARCHAR2(30) := 'FAILED';      -- Workflow run fails
  WORKFLOW_STATUS_SCHEDULED     CONSTANT VARCHAR2(30) := 'SCHEDULED';   -- Workflow has been scheduled to run

  WORKFLOW_NODE_STATUS_INVAL    CONSTANT VARCHAR2(30) := 'Invalid';   -- not ready for execution
  WORKFLOW_NODE_STATUS_STALE    CONSTANT VARCHAR2(30) := 'Stale';     -- setting has been changed, data/result becomes stale
  WORKFLOW_NODE_STATUS_WARN     CONSTANT VARCHAR2(30) := 'Warning';   -- execution is complete but with warning
  WORKFLOW_NODE_STATUS_READY    CONSTANT VARCHAR2(30) := 'Ready';     -- ready for execution
  WORKFLOW_NODE_STATUS_FAIL     CONSTANT VARCHAR2(30) := 'Failure';   -- execution failed
  WORKFLOW_NODE_STATUS_DONE     CONSTANT VARCHAR2(30) := 'Complete';  -- execution succeed

  WORKFLOW_MODEL_STATUS_READY   CONSTANT VARCHAR2(30) := 'Ready';     -- model ready for build/rebuild
  WORKFLOW_MODEL_STATUS_FAIL    CONSTANT VARCHAR2(30) := 'Failure';   -- model build failed
  WORKFLOW_MODEL_STATUS_DONE    CONSTANT VARCHAR2(30) := 'Complete';  -- model build succeed
  WORKFLOW_MODEL_STATUS_WARN    CONSTANT VARCHAR2(30) := 'Warning';   -- execution is complete but with warning

  WORKFLOW_MODEL_R_STATUS_INVAL CONSTANT VARCHAR2(30) := 'Invalid';   -- model ref invalid
  WORKFLOW_MODEL_R_STATUS_VALID CONSTANT VARCHAR2(30) := 'Valid';   -- model ref valid

  WORKFLOW_ATTR_STATUS_VALID    CONSTANT VARCHAR2(30) := 'Valid';     -- valid attribute
  WORKFLOW_ATTR_STATUS_INVAL    CONSTANT VARCHAR2(30) := 'Invalid';   -- invalid attribute (e.g. datatype change)
  --WORKFLOW_ATTR_STATUS_MISSING  CONSTANT VARCHAR2(30) := 'Missing';   -- missing attribute

  -- activity chain job status level
  /*
  WORKFLOW_JOB_STATUS_WARN      CONSTANT VARCHAR2(5) := 'WARN';
  WORKFLOW_JOB_STATUS_ERR       CONSTANT VARCHAR2(5) := 'ERR';
  WORKFLOW_JOB_STATUS_INFO      CONSTANT VARCHAR2(5) := 'INFO';
  */
  -- constants in meta model
  WORKFLOW_DATA_TYPE_STR          CONSTANT VARCHAR2(30) := 'STRING';
  WORKFLOW_DATA_TYPE_NUM          CONSTANT VARCHAR2(30) := 'NUMBER';

  WORKFLOW_MINING_TYPE_CAT        CONSTANT VARCHAR2(30) := 'Categorical';
  WORKFLOW_MINING_TYPE_NUM        CONSTANT VARCHAR2(30) := 'Numerical';
  WORKFLOW_MINING_TYPE_TEXT       CONSTANT VARCHAR2(30) := 'Text';
  WORKFLOW_MINING_TYPE_TXTCUSTOM  CONSTANT VARCHAR2(30) := 'TextCustom';

  -- workflow nodel type
  WF_NODE_TYPE_DATASOURCE     CONSTANT VARCHAR2(30) := 'DataSource';
  WF_NODE_TYPE_CREATETABLE    CONSTANT VARCHAR2(30) := 'CreateTable';
  WF_NODE_TYPE_UPDATETABLE    CONSTANT VARCHAR2(30) := 'UpdateTable';
  WF_NODE_TYPE_DATAPROFILE    CONSTANT VARCHAR2(30) := 'DataProfile';
  WF_NODE_TYPE_TRANSFORMATION CONSTANT VARCHAR2(30) := 'Transformation';
  WF_NODE_TYPE_AGGREGATION    CONSTANT VARCHAR2(30) := 'Aggregation';
  WF_NODE_TYPE_JOIN           CONSTANT VARCHAR2(30) := 'Join';
  WF_NODE_TYPE_TEXT           CONSTANT VARCHAR2(30) := 'BuildTextRef';
  WF_NODE_TYPE_BUILDTEXT      CONSTANT VARCHAR2(30) := 'BuildText';
  WF_NODE_TYPE_APPLYTEXT      CONSTANT VARCHAR2(30) := 'ApplyText';
  WF_NODE_TYPE_SPLIT          CONSTANT VARCHAR2(30) := 'Split';
  WF_NODE_TYPE_SAMPLE         CONSTANT VARCHAR2(30) := 'Sample';
  WF_NODE_TYPE_COLUMNFILTER   CONSTANT VARCHAR2(30) := 'ColumnFilter';
  WF_NODE_TYPE_ROWFILTER      CONSTANT VARCHAR2(30) := 'RowFilter';
  WF_NODE_TYPE_CLASS_BUILD    CONSTANT VARCHAR2(30) := 'ClassificationBuild';
  WF_NODE_TYPE_REGRESS_BUILD  CONSTANT VARCHAR2(30) := 'RegressionBuild';
  WF_NODE_TYPE_CLUST_BUILD    CONSTANT VARCHAR2(30) := 'ClusteringBuild';
  WF_NODE_TYPE_ASSOC_BUILD    CONSTANT VARCHAR2(30) := 'AssociationBuild';
  WF_NODE_TYPE_FEATURE_BUILD  CONSTANT VARCHAR2(30) := 'FeatureExtractionBuild';
  WF_NODE_TYPE_ANOMALY_BUILD  CONSTANT VARCHAR2(30) := 'AnomalyDetectionBuild';
  WF_NODE_TYPE_MODEL          CONSTANT VARCHAR2(30) := 'Model';
  WF_NODE_TYPE_APPLY          CONSTANT VARCHAR2(30) := 'Apply';
  WF_NODE_TYPE_TEST           CONSTANT VARCHAR2(30) := 'Test';
  WF_NODE_TYPE_MODELDETAILS   CONSTANT VARCHAR2(30) := 'ModelDetails';
  WF_NODE_TYPE_TESTDETAILS    CONSTANT VARCHAR2(30) := 'TestDetails';
  WF_NODE_TYPE_FILTERDETAILS  CONSTANT VARCHAR2(30) := 'FilterDetails';
  WF_NODE_TYPE_DYN_PREDICT    CONSTANT VARCHAR2(30) := 'DynamicPrediction';
  WF_NODE_TYPE_DYN_CLUSTER    CONSTANT VARCHAR2(30) := 'DynamicCluster';
  WF_NODE_TYPE_DYN_ANOMALY    CONSTANT VARCHAR2(30) := 'DynamicAnomaly';
  WF_NODE_TYPE_DYN_FEATURE    CONSTANT VARCHAR2(30) := 'DynamicFeature';
  WF_NODE_TYPE_SQLQUERY       CONSTANT VARCHAR2(30) := 'SQLQuery';
  WF_NODE_TYPE_GRAPH          CONSTANT VARCHAR2(30) := 'Graph';
  WF_NODE_TYPE_JSONQUERY      CONSTANT VARCHAR2(30) := 'JSONQuery';
  WF_NODE_TYPE_EFE_BUILD      CONSTANT VARCHAR2(30) := 'ExplicitFeatureExtractionBuild';  
  WF_NODE_TYPE_FEATURECOMPARE CONSTANT VARCHAR2(30) := 'FeatureCompare';
  WF_NODE_TYPE_R_BUILD        CONSTANT VARCHAR2(30) := 'RBuild';

  -- system defined types
  WF_NODE_TYPE_STARTUP        CONSTANT VARCHAR2(30) := 'WF_START';
  WF_NODE_TYPE_CLEANUP        CONSTANT VARCHAR2(30) := 'WF_END';
  WF_NODE_TYPE_SUBFLOW_ENTER  CONSTANT VARCHAR2(30) := 'E';
  WF_NODE_TYPE_SUBFLOW_EXIT   CONSTANT VARCHAR2(30) := 'X';

  -- build node models
  WF_NODE_BUILD_NB            CONSTANT VARCHAR2(30) := 'NaiveBayesModel';
  WF_NODE_BUILD_DT            CONSTANT VARCHAR2(30) := 'DecisionTreeModel';
  WF_NODE_BUILD_SVMC          CONSTANT VARCHAR2(30) := 'CSupportVectorMachineModel';
  WF_NODE_BUILD_GLMC          CONSTANT VARCHAR2(30) := 'CGeneralizedLinearModel';
  WF_NODE_BUILD_SVMR          CONSTANT VARCHAR2(30) := 'RSupportVectorMachineModel';
  WF_NODE_BUILD_GLMR          CONSTANT VARCHAR2(30) := 'RGeneralizedLinearModel';
  WF_NODE_BUILD_OC            CONSTANT VARCHAR2(30) := 'OClusterModel';
  WF_NODE_BUILD_KM            CONSTANT VARCHAR2(30) := 'KMeansModel';
  WF_NODE_BUILD_EM            CONSTANT VARCHAR2(30) := 'ExpectationMaximizationModel';
  WF_NODE_BUILD_AR            CONSTANT VARCHAR2(30) := 'AprioriModel';
  WF_NODE_BUILD_NMF           CONSTANT VARCHAR2(30) := 'NonNegativeMatrixFactorModel';
  WF_NODE_BUILD_SVD           CONSTANT VARCHAR2(30) := 'SVDModel';
  WF_NODE_BUILD_PCA           CONSTANT VARCHAR2(30) := 'PCAModel';
  WF_NODE_BUILD_AI            CONSTANT VARCHAR2(30) := 'MinimumDescriptionLengthModel';
  WF_NODE_BUILD_SVMO          CONSTANT VARCHAR2(30) := 'AnomalyDetectionModel';
  WF_NODE_BUILD_ESA           CONSTANT VARCHAR2(30) := 'ExplicitSemanticAnalysisModel';  
  WF_NODE_BUILD_R             CONSTANT VARCHAR2(30) := 'RModel';

  CACHE_SAMPLE_SIZE           CONSTANT VARCHAR2(30) := 'CACHE_SAMPLE_SIZE';     -- Cache data sample size

  --SAMPLE_ROW_COUNT         CONSTANT VARCHAR2(30) := 'SAMPLE_ROW_COUNT';
  MAX_TARGET_DISTINCT_COUNT  CONSTANT VARCHAR2(30) := 'MAX_TARGET_DISTINCT_COUNT';
  UNIQUE_PERCENTAGE          CONSTANT VARCHAR2(30) := 'UNIQUE_PERCENTAGE';
  MAX_DISTINCT_CAT_CUTOFF    CONSTANT VARCHAR2(30) := 'MAX_DISTINCT_CAT_CUTOFF';
  PERCENT_UNI_THRESHOLD_CAT  CONSTANT VARCHAR2(30) := 'PERCENT_UNI_THRESHOLD_CAT';
  CUTOFF_FOR_NUMBER_FOR_CAT  CONSTANT VARCHAR2(30) := 'CUTOFF_FOR_NUMBER_FOR_CAT';
  SPARSITY_CUTOFF            CONSTANT VARCHAR2(30) := 'SPARSITY_CUTOFF';
  --MAX_NUMERICAL_BIN        CONSTANT VARCHAR2(30) := 'MAX_NUMERICAL_BIN';
  --MAX_CATEGORICAL_BIN      CONSTANT VARCHAR2(30) := 'MAX_CATEGORICAL_BIN';
  MAX_DISTINCT_STRAT_SAMPLE  CONSTANT VARCHAR2(30) := 'MAX_DISTINCT_STRAT_SAMPLE';
  --MAX_WORKFLOW_LOG_COUNT     CONSTANT VARCHAR2(30) := 'MAX_WORKFLOW_LOG_COUNT';  -- keep most recent 100000 workflow run log
  
  MAX_NUM_THREADS            CONSTANT VARCHAR2(30) := 'MAX_NUM_THREADS';
  MAX_THREAD_WAIT            CONSTANT VARCHAR2(30) := 'MAX_THREAD_WAIT';
  THREAD_WAIT_TIME           CONSTANT VARCHAR2(30) := 'THREAD_WAIT_TIME';
  WORKFLOW_JOB_CLASS         CONSTANT VARCHAR2(30) := 'WORKFLOW_JOB_CLASS';
  WORKFLOW_JOB_CLASS_ALLOWED CONSTANT VARCHAR2(30) := 'WORKFLOW_JOB_CLASS_ALLOWED';
  USE_PARALLEL               CONSTANT VARCHAR2(30) := 'USE_PARALLEL';

  POLLING_IDLE_RATE          CONSTANT VARCHAR2(30) := 'POLLING_IDLE_RATE';
  POLLING_ACTIVE_RATE        CONSTANT VARCHAR2(30) := 'POLLING_ACTIVE_RATE';
  POLLING_COMPLETED_WINDOW   CONSTANT VARCHAR2(30) := 'POLLING_COMPLETED_WINDOW';
  PURGE_WORKFLOW_SCHEDULER_OBJS CONSTANT VARCHAR2(30) := 'PURGE_WORKFLOW_SCHEDULER_OBJS';
  PURGE_WORKFLOW_EVENT_LOG   CONSTANT VARCHAR2(30) := 'PURGE_WORKFLOW_EVENT_LOG';

  -- JSON DataGuideGenEnum values
  DATAGUIDE_DEFAULT          CONSTANT VARCHAR2(30) := 'DEFAULT';
  DATAGUIDE_OFF              CONSTANT VARCHAR2(30) := 'OFF';
  DATAGUIDE_ON               CONSTANT VARCHAR2(30) := 'ON';

  -- Supported JSON Attribute Data Types
  JSON_OBJECT               CONSTANT VARCHAR2(30) := 'OBJECT';
  JSON_ARRAY                CONSTANT VARCHAR2(30) := 'ARRAY';
  JSON_NUMBER               CONSTANT VARCHAR2(30) := 'NUMBER';
  JSON_STRING               CONSTANT VARCHAR2(30) := 'STRING';
  JSON_BOOLEAN              CONSTANT VARCHAR2(30) := 'BOOLEAN';
  JSON_NULL                 CONSTANT VARCHAR2(30) := 'NULL';
END;
/
